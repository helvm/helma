module HelVM.HelMA.Automaton.AOT where

--import           HelVM.HelMA.Automaton.Instruction
--import           HelVM.HelMA.Automaton.Loop           as Loop
--
--import           HelVM.HelMA.Automaton.Symbol
--
--import           HelVM.HelMA.Automaton.IO.AutomatonIO
--
----import           HelVM.HelIO.ListLikeExtra
--
--import           Control.Type.Operator
--
----import           Data.List.Split
--import           Data.List.Extra

--splitILByMark :: InstructionList -> [InstructionList]
--splitILByMark = split2 isMark
--
--split2 :: (a -> Bool) -> [a] -> [[a]]
--split2 f [] = [[]]
--split2 f (x : xs) | f x = [x] : split f xs
--split2 f (x : xs) | y:ys <- split2 f xs = (x:y) : ys
--
----aaa :: InstructionList ->
----aaa ((ICF (SMark _)) : il) = compile il
--
--compile il = compileInstruction <$> il
--
--compileInstruction :: (SRAutomatonIO Symbol s r m) => Instruction -> AOT s r -> m $ AOT s r
--compileInstruction (IAL      i) u = Loop.continue . updateStack   u <$> runALI i (unitStack u)
--compileInstruction (ILS      i) u = Loop.continue . updateFromLSU u <$> runSLI i (toLSU u)
--compileInstruction (ICF      i) u = Loop.continue . updateFromCPU u <$> runCFI i (toCPU u)
--compileInstruction  Transfer    u = transfer u
--compileInstruction  End         u = end u
--
--
----transfer :: (SRAutomatonIO Symbol s r m) => Automaton s r -> m $ AutomatonSame s r
--transfer = error
--
--end = pure . id
--
--
---- | Types
----type AOTSame s r = Same (AOT s r)
--
---- | Data types
--data AOT s r = AOT
--  { is :: IS
--  , unitStack :: s
--  , unitRAM   :: r
--  }
--  deriving stock (Show)
